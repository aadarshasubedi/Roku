.Roku
旧 Rokuはクラスベースのコンパイラだったが、スロット周りの仕様をややこしくし過ぎたため
パーサとコード生成部を一部作り直しシンプルな言語にすることが目的
名前は気に入ってたのでRokuのままにしたい

* 型のみ実装し、クラスは実装しない
* 関数の仕様はシンプルにする、スロットの実装はすべて消す
* 総称型は残す
* インデントベースのパーサを使ってみる
* ifは文として実装する
* 先行評価の静的型付け言語に戻す
* CILのコード生成を優先的に実装する
* VS2015のVBでコードを全面的に書き直す(旧 RokuはVS2005/.NET Framework2だから色々面倒だった)
* ソース管理にGitを使ってみる



.パース部(Parse)
ソースコードをNodeツリーに変換する
若干文法変えているが基本は変わらない

スロットのややこしい仕様をなくしたためFunctionNodeは直接関数本体(BlockNode)を持つ
今回IScopeNodeの実装はBlockNodeしかいらない

関数本体はIRunnableNodeを廃止し、IEvaluableNodeの配列で持つ
if文のように戻り値を持たないものもIEvaluableNodeでTypeをVoidにでもしておけばいい
IRunnableNodeをリンクリストで持つ従来の形式は.NETでは扱いがめんどくさかったので
IEvaluableNodeはListで持つように変更する

名前空間をCompilerにせずParserとかにして
後続のファイルと保存フォルダ分けたい


.名前解決(NameResolve)
ほぼそのまま使えるはず

直接は関係ないけどNodeOperatorを実装しなおす
名前解決から翻訳までNodeOperatorを継承して処理を作っているが
継承しなくても使えるようにならないか?
昔のVBの構文ではこの程度で妥協してたけど、今ではちょっとダサい

旧のMain.vbのエラートラップが非常にダサい
複数のエラー発生をトラップすることを前提にし
CatchErrorイベントを各 名前解決〜翻訳までのインスタンスごとにAddHandlerしている
なんとかできないのか?

やりたいことは、エラーが発生したらThrowして復帰可能な位置でCatchしてエラー表示して
次の処理をした後に各処理が一段落したらアベンドする


.正規化(Normalize)
これもほぼそのまま使えるはず


.クロージャー変換(Closure)
これもほぼそのまま使えるはず


.型付け(Typing)
だいぶ変えないといけない
とりあえず型(struct)と関数だけ実装する
総称型は後でもいい

型チェックを直さないといけないがだいぶ後でいい


.中間コード翻訳(Translater)
OpCodeという名前は.NETの名前とかぶっていたのでRkCodeに変更する
それに伴いOpのプレフィックスはRkに変更する

OpCodeはそれぞれOpCode0を基本型にし、4つに分けていた
  OpCode0・・・コードのみ(NOPやRETURNなど)
  OpCode1・・・コードと戻り値のみ(RETURN)
  OpCode2・・・コードと戻り値と引数1(単項演算のMULなど)
  OpCode3・・・コードと戻り値と引数2(ADDやMULなど)
この形式ではコードと型のチェックをしコード出力を行っていたため、分岐が増えた
1つのコードには1つの引数形式を持たせる
コードを分けないといけないのはRETURN(引数ありなし)と単項演算子ぐらいである
RkCodeでは上記をふまえRETURN_0とRETURN1、MUL_1とMULを作る
3番地コード形式のみしか用意しない


.コード出力(Assemble)
RIRはなくてもいい、CILから作る
最適化はだいぶ後でいい

元はクラスベースであったためCILでもクラスを作っていたが
全てshared functionで作るか??


.設計方針

オブジェクト指向は弊害が多いため最小限にとどめる

* クラスメンバ変数はほぼPublicにする
* Privateなメンバ変数はアクセサを作るか関数にする
* クラスメンバ関数は非破壊関数にする
  破壊関数は戻り値なしにする
* コンストラクタはなるべく作らない、呼び出し側でNew Withする
* 初期化以外のタイミングでなるべくクラスメンバ変数への再代入を避ける
* できればデータ定義するクラスには処理を書かず、操作のみするStaticな関数を設ける
* なるべく継承は用いない
* 他のオブジェクトを参照するメンバ関数はなるべく作らない
  処理の主体が自オブジェクトなら作って構わない

.総称型を使うために

struct Foo(@T1, @T2)
	var a : Int
	var b : @T1
	var c : @T2
var x = Foo.of Int String
var y = Foo.of String Bar
sub f1.of(@T1, @T2)(m : Foo.of @T1 @T2)
	print m
f1 x
var fx = f1.of Baz Int
struct Hoge(@T1)
	var a : Foo.of Int @T
↓
Dim Foo As New RkStruct With {.Name = "Foo"}
Foo.AddVar("a", Int)
Foo.AddVar("b", Foo.DefineGeneric("@T1"))
Foo.AddVar("c", Foo.DefineGeneric("@T2"))
Dim x = Foo.FixedGeneric(Int, String)
Dim y = Foo.FixedGeneric(String, Bar)
Dim f1 As New RkFunction With {.Name = "f1"}
f1.Arguments.Add("m", Foo.FixedGeneric(f1.DefineGeneric("@T1"), f1.DefineGeneric("@T2")))
f1.FixedGeneric(x)
Dim fx = f1.FixedGeneric(Baz, Int)
Dim Hoge As New RkStruct With {.Name = "Hoge"}
Hoge.AddVar("a", Foo.FixedGeneric(Int, Hoge.DefineGeneric("@T")))

.Namespaceと型の実装

RkNamespaceはuse、struct、sub、namespaceを持つ
RkStructはletしか持たない(letの初期化はコンストラクタという特別なsubを持つ)
RkFunctionはlet、struct、subを持つ

struct RkNamespace
    var Local    = Dictionary(String, RkStruct | RkFunction | RkNamespace)
    var LoadPath = List(RkStruct | RkNamespace)

struct RkStruct
    var Vars = Dictionary(String, LetNode)
    var Ctor = RkFunction()

struct RkFunction
    var Local = Dictionary(String, RkStruct | RkFunction | LetNode)


.総称型の実装

総称型はC++のテンプレートのインライン展開(だっけ？)のように扱う

sub add(a: @T, b: @T) @T
    return(a + b)
add(1, 2)     #=> 3
add("a", "b") #=> ab
add(Hoge(), Hoge()) #=> ERROR!!

総称型に特に制約のない限り、add関数の定義時点では「a + b」という構文は問題ない
IntやString同士には「+」関数が定義されているため「add(1, 2)」「add("a", "b")」という呼び出しは間違いではない
ただHoge型の足し算は未定義のため「add(Hoge(), Hoge())」という呼び出しの時点でエラーとしたい

従来「型付け→中間コード翻訳」という順に処理をしていたが
逆にするか、型付けの前に呼び出し側を展開する処理を挟む必要がある

..型付けの前にする事

sub add(a: @T, b: @T) @T を

sub add(a: Int, b: Int) Int と
sub add(a: String, b: String) String と
sub add(a: Hoge, b: Hoge) Hoge を作る

型付けで
sub add(a: Hoge, b: Hoge) Hoge がエラーになればよい
エラーメッセージは「add(Hoge(), Hoge())」の行がエラーと出たほうがいい

..中間コード翻訳について

sub add(a: @T, b: @T) @T を中間コードに落とす必要はなくなる
インライン展開するわけだからコードサイズは大きくなる
内部的に関数のオーバーロードが出来ないといけない

.中間コード翻訳、コード出力について

中間コードにする際、従来 Node→RIR としていたが
総称型の解決のために Node→RkFunction を呼び出しごとに作っている

総称型を解決した際にキャッシュを作り Node→RkFunction(@T)→RkFunction という流れを作る

..別案 2016/01/04

Node→RkFunction(@T)→RkFunction だと中間コード翻訳時点でNodeのStatementsが
型が確定していない
中間コード作成時にまた解決とかを行わないといけないのでめんどくさい

すこし無駄が増えるが下記モデルのほうが後続処理がやりやすい
Node(@T)→RkFunction(@T)
  ├→Node(Int)→RkFunction(Int)
  └→Node(String)→RkFunction(String)

この場合、総称型に依存しないインナー関数はNode(@T)にあったほうが無駄がないとか
改善案はあるが、とりあえずこの形にしてみる

RkFunctionに用意した @T() -> RkFunction は消して
Nodeに @T -> Node を用意する
RkFunction.DefineGeneric はそのまま残すが、Node.DefineGeneric 相当を作る

多段階に展開されるとこうなる？
sub f1(a: @T) @T
	return(a)
sub f2(a: @T2) @T2
	return(f1(a))
var a = f2(1)

Node(f1 @T)→RkFunction(@T)
  └→Node(f1 @T2)→RkFunction(@T2)
      └→Node(f1 Int)→RkFunction(Int)
Node(f2 @T2)→RkFunction(@T2)
  └→Node(f2 Int)→RkFunction(Int)

欠点：
  名前解決、クロージャー変換を再実行しないとちゃんとならない
  これをさぼると結局めんどくさい

..別案 2016/01/05

中間コード翻訳で部分的な型解決(RkGenericEntryに限る)をできるようにする
RkGenericEntry.Referenceに解決後の型を入れる

FunctionNode(@T1, @T2)→RkFunction(@T1, @T2)
これを
FunctionCallNode(t1, t2)
FunctionCallNode(t3, t4)
から
FunctionNode(@T1, @T2)→RkFunction(@T1, @T2)
  ├→Cache(t1, t2)→RkFunction(t1, t2)
  └→Cache(t3, t4)→RkFunction(t3, t4)
となる

sub f(FunctionNode, FunctionCallNode)->RkFunction
が必要になる
処理は簡単に書くとこうなる
(FunctionNode, FunctionCallNode) => @T[]
(FunctionNode, RkFunction, @T[]) => RkFunction'
FunctionNode.Cache(@T[] -> RkFunction')

一度で解決しきれない時が若干面倒
sub f1(a: @T1, b: @T2)
sub f2(c: @T3)
	f1(1, c)
f2(2)

sub translation(node)
	if node is FunctionNode
		func_translation(node)
	else if node is FunctionCallNode
		call_translation(node)
	else
		...
sub func_translation(node: FunctionNode)
	if !node.IsGeneric
		func_translation'(node, @T[])
sub func_translation'(node: FunctionNode, types: @T[])
	var needs   = node.FixedParameter(types)
	var rk_func = node.FixedGeneric(needs)
	if !rk_func.Completed
		rk_func ...
		rk_func.Completed = true
		node.Cache(needs, rk_func)
sub call_translation(node: FunctionCallNode)
	node.Function = func_translation'(node.Expression.Type: FunctionNode, node.Arguments)

.関数の呼び出し

関数の呼び出し方法は何パターンかある

まずレシーバを伴わない関数呼び出し

struct Hoge
	var a = 1
sub f()
	return(1)

f()            # 関数名をそのままコールする、FunctionCallNode->FunctionNodeとなる
print()        # システム組み込みの関数をコールする、FunctionCallNode->VariableNodeとなり関数の検索が必要
var x = f
x()            # 変数経由でコールする、FunctionCallNode->VariableNode(RkFunction)となり関数の検索が不要
var h = Hoge() # 構造体の作成をする、FunctionCallNode->StructNodeとなる、#Allocという特別な関数を呼び出す
var y = Hoge
y()            # 変数経由で構造体の作成をする、FunctionCallNode->VariableNode(RkStruct)となる

現時点では
FunctionCallNode->VariableNode(RkFunction) と
FunctionCallNode->VariableNode(RkStruct) が対応できていない

..レシーバを伴う関数の呼び出し

いわゆるメソッドの実装方法
今回クラスは実装しないが、メソッドの書き方は取り入れたい

よくあるクラス型のメソッドの悪い点はこれにつきる
* クラス定義とメソッドは同時に記述する、つまりクラス記述者しかメソッドを増やせない
  動的言語ならメソッドを追加できるものもある
  最近の.NET系ではExtensionがありメソッド追加に見せかけることもできる

メソッドを追加できないためこういう問題が起こる

* メソッドは1クラスづつにしか追加できない(独自メソッドは継承して追加する
  スーパークラスに追加して派生クラスで使うことはできない
* 組み込み型にメソッドが追加できない、IntやString型に独自メソッドを定義できない

例えばgrep、map、sort、do関数を順に呼び出す場合
do(sort(map(grep([1, 2, 3], x => x > 1), x => "" + x)), x => print(x)) となる
Haskellならdo関数なんてないけど、勢いで書くとこんな感じ
do (x -> print x) $ sort $ grep (x -> x > 1) $ map [1, 2, 3] こうかな
右から順に考えていくのが嫌だ

レシーバが使えるなら自然と左から順になる
[1, 2, 3].grep(x => x > 1).map(x => "" + x).sort().do(x => print(x))

..対応案 2016/01/23

第一引数をレシーバにできる

sub grep(self: @T[], f: (@T => Bool)) @T[]
sub map(self: @T[], f: (@T => @R)) @R[]
sub sort(self: @T[]) @T[]
sub do(self: @T[], f: (@T))
があるとき

[1, 2, 3].grep(x => x > 1).map(x => "" + x).sort().do(x => print(x))
としてよい

欠点:
こうしてもよいわけで、どちらでもいいというのは一貫性がない
do(sort(map(grep([1, 2, 3], x => x > 1), x => "" + x)), x => print(x))

..対応案 2016/01/24

メソッドと関数は表記を変える、メソッド形式でしか呼び出せなくする
レシーバはselfという名前を自動でつける
sub @T[].map(f: (@T=>@R)) @R[]
sub @T[].grep(f: (@T=>Bool)) @T[]
sub @T[].sort(f: @T[]) @T[]
sub @T[].do(f: (@T))

欠点:
レシーバ変数名が固定になる

利点:
よりメソッドっぽくなる
sub String.compare(a: String) Bool

.ToDo

  テストケースのチェック自動化
! 組み込み型(Int、Float、Bool、Array、Char、String、Date)
  配列
! 四則演算(Intのみ対応)
  比較演算
o 関数呼び出し
  メソッド呼び出し
  演算子定義
  クロージャ変換
  関数型の引数、戻り値
  部分適用
! 関数の総称型対応(段階を踏むケースは未対応 sub f(@T,@R), f2(@T) = f(1, @T), f2(2))
o 構造体のnew
  構造体の総称型対応
  構造体の継承
  構造体のキャスト
  別型への型変換(IntからFloatなど)
! if文(ifのcond部分にカッコをつけるか検討)
  ネームスペースの実装
  複数ファイルからのコンパイル
  .NETのインポート
  コマンドラインオプションをArchitectureへの適用
  コンパイルエラーメッセージ
